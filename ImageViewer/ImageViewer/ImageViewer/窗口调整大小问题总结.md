# 窗口调整大小问题总结

## 问题描述

在将 ApplicationWindow 改为无边框窗口并实现自定义标题栏后，窗口调整大小功能存在以下问题：

### 主要问题
1. **抖动和残影**：调整窗口大小时窗口位置和大小频繁变化，导致视觉上的抖动
2. **不平滑**：窗口调整过程不流畅，有卡顿感
3. **位置偏移**：调整过程中窗口位置可能发生不期望的偏移

## 当前实现分析

### 现有调整区域
- 左侧边框：水平调整宽度
- 右侧边框：水平调整宽度
- 底部边框：垂直调整高度
- 左下角：同时调整宽度和高度
- 右下角：同时调整宽度和高度

### 技术实现问题

1. **坐标系统混乱**：
   - 使用局部坐标和全局坐标混合计算
   - `mapToGlobal` 和局部坐标 `mouse.x` 混用
   - 导致位置计算不准确

2. **频繁更新**：
   - `onPositionChanged` 中频繁调用窗口属性更新
   - 没有使用原子操作一次性更新位置和大小

3. **基准点问题**：
   - 使用 `startX`、`startWidth` 等作为基准
   - 但在调整过程中基准值可能被修改

## 问题代码示例

```qml
// 左侧边框 - 问题代码
onPositionChanged: function(mouse) {
    if (pressed) {
        var globalPos = mapToGlobal(mouse.x, mouse.y)
        var deltaX = globalPos.x - startX
        var newWidth = Math.max(minimumWidth, startWidth - deltaX)

        if (newWidth > minimumWidth) {
            window.x = startX + deltaX  // 这里可能引起抖动
            window.width = newWidth     // 这里可能引起抖动
        }
    }
}
```

## 根本原因

1. **非原子操作**：分别设置 `window.x` 和 `window.width` 而不是使用 `setGeometry()`
2. **坐标转换错误**：局部坐标和全局坐标的转换不准确
3. **事件处理频率**：`onPositionChanged` 触发频率过高，导致频繁重绘

## 建议解决方案

### 方案1：使用系统原生调整
```qml
// 使用 Qt 提供的系统调整方法
onPressed: function(mouse) {
    window.startSystemResize(Qt.LeftEdge)
}
```

### 方案2：改进现有实现
```qml
// 使用 setGeometry 一次性更新
onPositionChanged: function(mouse) {
    if (pressed) {
        var deltaX = mouse.x - clickPos.x
        var newWidth = Math.max(minimumWidth, startSize.width - deltaX)
        window.setGeometry(window.x + deltaX, window.y, newWidth, window.height)
    }
}
```

### 方案3：使用定时器缓冲
```qml
// 使用定时器减少更新频率
Timer {
    id: resizeTimer
    interval: 16 // 约60fps
    repeat: false
    onTriggered: {
        // 执行窗口调整
    }
}
```

## 优先级

1. **高优先级**：解决抖动和残影问题
2. **中优先级**：确保调整过程平滑
3. **低优先级**：添加更多调整区域（如顶部边框）

## 测试建议

1. 分别测试每个调整区域的平滑度
2. 测试最小尺寸限制是否正常工作
3. 测试窗口位置是否保持稳定
4. 测试多显示器环境下的表现

## 备注

- 当前实现已经比最初版本有所改进
- 需要进一步优化坐标计算和更新机制
- 考虑使用 Qt 原生方法可能更稳定